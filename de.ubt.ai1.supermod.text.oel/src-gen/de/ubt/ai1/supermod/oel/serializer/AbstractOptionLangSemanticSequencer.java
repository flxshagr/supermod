/*
 * generated by Xtext
 */
package de.ubt.ai1.supermod.oel.serializer;

import com.google.inject.Inject;
import de.ubt.ai1.supermod.mm.core.AndExpr;
import de.ubt.ai1.supermod.mm.core.BiconditionalExpr;
import de.ubt.ai1.supermod.mm.core.BigAndExpr;
import de.ubt.ai1.supermod.mm.core.BigNandExpr;
import de.ubt.ai1.supermod.mm.core.BigOrExpr;
import de.ubt.ai1.supermod.mm.core.BigXorExpr;
import de.ubt.ai1.supermod.mm.core.ImpliesExpr;
import de.ubt.ai1.supermod.mm.core.MinusExpr;
import de.ubt.ai1.supermod.mm.core.NandExpr;
import de.ubt.ai1.supermod.mm.core.NegExpr;
import de.ubt.ai1.supermod.mm.core.OptionRef;
import de.ubt.ai1.supermod.mm.core.OrExpr;
import de.ubt.ai1.supermod.mm.core.SuperModCorePackage;
import de.ubt.ai1.supermod.mm.core.XorExpr;
import de.ubt.ai1.supermod.oel.services.OptionLangGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractOptionLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private OptionLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SuperModCorePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SuperModCorePackage.AND_EXPR:
				sequence_AndExpr(context, (AndExpr) semanticObject); 
				return; 
			case SuperModCorePackage.BICONDITIONAL_EXPR:
				sequence_BiconditionalExpr(context, (BiconditionalExpr) semanticObject); 
				return; 
			case SuperModCorePackage.BIG_AND_EXPR:
				sequence_BigAndExpr(context, (BigAndExpr) semanticObject); 
				return; 
			case SuperModCorePackage.BIG_NAND_EXPR:
				sequence_BigNandExpr(context, (BigNandExpr) semanticObject); 
				return; 
			case SuperModCorePackage.BIG_OR_EXPR:
				sequence_BigOrExpr(context, (BigOrExpr) semanticObject); 
				return; 
			case SuperModCorePackage.BIG_XOR_EXPR:
				sequence_BigXorExpr(context, (BigXorExpr) semanticObject); 
				return; 
			case SuperModCorePackage.IMPLIES_EXPR:
				sequence_ImpliesExpr(context, (ImpliesExpr) semanticObject); 
				return; 
			case SuperModCorePackage.MINUS_EXPR:
				sequence_MinusExpr(context, (MinusExpr) semanticObject); 
				return; 
			case SuperModCorePackage.NAND_EXPR:
				sequence_NandExpr(context, (NandExpr) semanticObject); 
				return; 
			case SuperModCorePackage.NEG_EXPR:
				sequence_NegExpr(context, (NegExpr) semanticObject); 
				return; 
			case SuperModCorePackage.OPTION_REF:
				sequence_OptionRef(context, (OptionRef) semanticObject); 
				return; 
			case SuperModCorePackage.OR_EXPR:
				sequence_OrExpr(context, (OrExpr) semanticObject); 
				return; 
			case SuperModCorePackage.XOR_EXPR:
				sequence_XorExpr(context, (XorExpr) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     OptionExpr returns AndExpr
	 *     BiconditionalExpr returns AndExpr
	 *     BiconditionalExpr.BiconditionalExpr_1_0 returns AndExpr
	 *     ImpliesExpr returns AndExpr
	 *     ImpliesExpr.ImpliesExpr_1_0 returns AndExpr
	 *     OrExpr returns AndExpr
	 *     OrExpr.OrExpr_1_0 returns AndExpr
	 *     XorExpr returns AndExpr
	 *     XorExpr.XorExpr_1_0 returns AndExpr
	 *     MinusExpr returns AndExpr
	 *     MinusExpr.MinusExpr_1_0 returns AndExpr
	 *     NandExpr returns AndExpr
	 *     NandExpr.NandExpr_1_0 returns AndExpr
	 *     AndExpr returns AndExpr
	 *     AndExpr.AndExpr_1_0 returns AndExpr
	 *     PrimaryExpr returns AndExpr
	 *
	 * Constraint:
	 *     (left=AndExpr_AndExpr_1_0 right=PrimaryExpr)
	 */
	protected void sequence_AndExpr(ISerializationContext context, AndExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExprAccess().getAndExprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExprAccess().getRightPrimaryExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OptionExpr returns BiconditionalExpr
	 *     BiconditionalExpr returns BiconditionalExpr
	 *     BiconditionalExpr.BiconditionalExpr_1_0 returns BiconditionalExpr
	 *
	 * Constraint:
	 *     (left=BiconditionalExpr_BiconditionalExpr_1_0 right=BiconditionalExpr)
	 */
	protected void sequence_BiconditionalExpr(ISerializationContext context, BiconditionalExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBiconditionalExprAccess().getBiconditionalExprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBiconditionalExprAccess().getRightBiconditionalExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OptionExpr returns BigAndExpr
	 *     BigExpr returns BigAndExpr
	 *     BigAndExpr returns BigAndExpr
	 *
	 * Constraint:
	 *     (children+=OptionExpr children+=OptionExpr*)
	 */
	protected void sequence_BigAndExpr(ISerializationContext context, BigAndExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OptionExpr returns BigNandExpr
	 *     BigExpr returns BigNandExpr
	 *     BigNandExpr returns BigNandExpr
	 *
	 * Constraint:
	 *     (children+=OptionExpr children+=OptionExpr*)
	 */
	protected void sequence_BigNandExpr(ISerializationContext context, BigNandExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OptionExpr returns BigOrExpr
	 *     BigExpr returns BigOrExpr
	 *     BigOrExpr returns BigOrExpr
	 *
	 * Constraint:
	 *     (children+=OptionExpr children+=OptionExpr*)
	 */
	protected void sequence_BigOrExpr(ISerializationContext context, BigOrExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OptionExpr returns BigXorExpr
	 *     BigExpr returns BigXorExpr
	 *     BigXorExpr returns BigXorExpr
	 *
	 * Constraint:
	 *     (children+=OptionExpr children+=OptionExpr*)
	 */
	protected void sequence_BigXorExpr(ISerializationContext context, BigXorExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OptionExpr returns ImpliesExpr
	 *     BiconditionalExpr returns ImpliesExpr
	 *     BiconditionalExpr.BiconditionalExpr_1_0 returns ImpliesExpr
	 *     ImpliesExpr returns ImpliesExpr
	 *     ImpliesExpr.ImpliesExpr_1_0 returns ImpliesExpr
	 *     OrExpr returns ImpliesExpr
	 *     OrExpr.OrExpr_1_0 returns ImpliesExpr
	 *     XorExpr returns ImpliesExpr
	 *     XorExpr.XorExpr_1_0 returns ImpliesExpr
	 *     MinusExpr returns ImpliesExpr
	 *     MinusExpr.MinusExpr_1_0 returns ImpliesExpr
	 *     NandExpr returns ImpliesExpr
	 *     NandExpr.NandExpr_1_0 returns ImpliesExpr
	 *     AndExpr returns ImpliesExpr
	 *     AndExpr.AndExpr_1_0 returns ImpliesExpr
	 *     PrimaryExpr returns ImpliesExpr
	 *
	 * Constraint:
	 *     (left=ImpliesExpr_ImpliesExpr_1_0 right=OrExpr)
	 */
	protected void sequence_ImpliesExpr(ISerializationContext context, ImpliesExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImpliesExprAccess().getImpliesExprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getImpliesExprAccess().getRightOrExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OptionExpr returns MinusExpr
	 *     BiconditionalExpr returns MinusExpr
	 *     BiconditionalExpr.BiconditionalExpr_1_0 returns MinusExpr
	 *     ImpliesExpr returns MinusExpr
	 *     ImpliesExpr.ImpliesExpr_1_0 returns MinusExpr
	 *     OrExpr returns MinusExpr
	 *     OrExpr.OrExpr_1_0 returns MinusExpr
	 *     XorExpr returns MinusExpr
	 *     XorExpr.XorExpr_1_0 returns MinusExpr
	 *     MinusExpr returns MinusExpr
	 *     MinusExpr.MinusExpr_1_0 returns MinusExpr
	 *     NandExpr returns MinusExpr
	 *     NandExpr.NandExpr_1_0 returns MinusExpr
	 *     AndExpr returns MinusExpr
	 *     AndExpr.AndExpr_1_0 returns MinusExpr
	 *     PrimaryExpr returns MinusExpr
	 *
	 * Constraint:
	 *     (left=MinusExpr_MinusExpr_1_0 right=NandExpr)
	 */
	protected void sequence_MinusExpr(ISerializationContext context, MinusExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMinusExprAccess().getMinusExprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMinusExprAccess().getRightNandExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OptionExpr returns NandExpr
	 *     BiconditionalExpr returns NandExpr
	 *     BiconditionalExpr.BiconditionalExpr_1_0 returns NandExpr
	 *     ImpliesExpr returns NandExpr
	 *     ImpliesExpr.ImpliesExpr_1_0 returns NandExpr
	 *     OrExpr returns NandExpr
	 *     OrExpr.OrExpr_1_0 returns NandExpr
	 *     XorExpr returns NandExpr
	 *     XorExpr.XorExpr_1_0 returns NandExpr
	 *     MinusExpr returns NandExpr
	 *     MinusExpr.MinusExpr_1_0 returns NandExpr
	 *     NandExpr returns NandExpr
	 *     NandExpr.NandExpr_1_0 returns NandExpr
	 *     AndExpr returns NandExpr
	 *     AndExpr.AndExpr_1_0 returns NandExpr
	 *     PrimaryExpr returns NandExpr
	 *
	 * Constraint:
	 *     (left=NandExpr_NandExpr_1_0 right=AndExpr)
	 */
	protected void sequence_NandExpr(ISerializationContext context, NandExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNandExprAccess().getNandExprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getNandExprAccess().getRightAndExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OptionExpr returns NegExpr
	 *     BiconditionalExpr returns NegExpr
	 *     BiconditionalExpr.BiconditionalExpr_1_0 returns NegExpr
	 *     ImpliesExpr returns NegExpr
	 *     ImpliesExpr.ImpliesExpr_1_0 returns NegExpr
	 *     OrExpr returns NegExpr
	 *     OrExpr.OrExpr_1_0 returns NegExpr
	 *     XorExpr returns NegExpr
	 *     XorExpr.XorExpr_1_0 returns NegExpr
	 *     MinusExpr returns NegExpr
	 *     MinusExpr.MinusExpr_1_0 returns NegExpr
	 *     NandExpr returns NegExpr
	 *     NandExpr.NandExpr_1_0 returns NegExpr
	 *     AndExpr returns NegExpr
	 *     AndExpr.AndExpr_1_0 returns NegExpr
	 *     PrimaryExpr returns NegExpr
	 *     NegExpr returns NegExpr
	 *
	 * Constraint:
	 *     neg=OptionExpr
	 */
	protected void sequence_NegExpr(ISerializationContext context, NegExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SuperModCorePackage.Literals.NEG_EXPR__NEG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SuperModCorePackage.Literals.NEG_EXPR__NEG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNegExprAccess().getNegOptionExprParserRuleCall_1_0(), semanticObject.getNeg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OptionExpr returns OptionRef
	 *     BiconditionalExpr returns OptionRef
	 *     BiconditionalExpr.BiconditionalExpr_1_0 returns OptionRef
	 *     ImpliesExpr returns OptionRef
	 *     ImpliesExpr.ImpliesExpr_1_0 returns OptionRef
	 *     OrExpr returns OptionRef
	 *     OrExpr.OrExpr_1_0 returns OptionRef
	 *     XorExpr returns OptionRef
	 *     XorExpr.XorExpr_1_0 returns OptionRef
	 *     MinusExpr returns OptionRef
	 *     MinusExpr.MinusExpr_1_0 returns OptionRef
	 *     NandExpr returns OptionRef
	 *     NandExpr.NandExpr_1_0 returns OptionRef
	 *     AndExpr returns OptionRef
	 *     AndExpr.AndExpr_1_0 returns OptionRef
	 *     PrimaryExpr returns OptionRef
	 *     OptionRef returns OptionRef
	 *
	 * Constraint:
	 *     option=[Option|ID]
	 */
	protected void sequence_OptionRef(ISerializationContext context, OptionRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SuperModCorePackage.Literals.OPTION_REF__OPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SuperModCorePackage.Literals.OPTION_REF__OPTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOptionRefAccess().getOptionOptionIDTerminalRuleCall_0_1(), semanticObject.eGet(SuperModCorePackage.Literals.OPTION_REF__OPTION, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OptionExpr returns OrExpr
	 *     BiconditionalExpr returns OrExpr
	 *     BiconditionalExpr.BiconditionalExpr_1_0 returns OrExpr
	 *     ImpliesExpr returns OrExpr
	 *     ImpliesExpr.ImpliesExpr_1_0 returns OrExpr
	 *     OrExpr returns OrExpr
	 *     OrExpr.OrExpr_1_0 returns OrExpr
	 *     XorExpr returns OrExpr
	 *     XorExpr.XorExpr_1_0 returns OrExpr
	 *     MinusExpr returns OrExpr
	 *     MinusExpr.MinusExpr_1_0 returns OrExpr
	 *     NandExpr returns OrExpr
	 *     NandExpr.NandExpr_1_0 returns OrExpr
	 *     AndExpr returns OrExpr
	 *     AndExpr.AndExpr_1_0 returns OrExpr
	 *     PrimaryExpr returns OrExpr
	 *
	 * Constraint:
	 *     (left=OrExpr_OrExpr_1_0 right=XorExpr)
	 */
	protected void sequence_OrExpr(ISerializationContext context, OrExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrExprAccess().getOrExprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrExprAccess().getRightXorExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OptionExpr returns XorExpr
	 *     BiconditionalExpr returns XorExpr
	 *     BiconditionalExpr.BiconditionalExpr_1_0 returns XorExpr
	 *     ImpliesExpr returns XorExpr
	 *     ImpliesExpr.ImpliesExpr_1_0 returns XorExpr
	 *     OrExpr returns XorExpr
	 *     OrExpr.OrExpr_1_0 returns XorExpr
	 *     XorExpr returns XorExpr
	 *     XorExpr.XorExpr_1_0 returns XorExpr
	 *     MinusExpr returns XorExpr
	 *     MinusExpr.MinusExpr_1_0 returns XorExpr
	 *     NandExpr returns XorExpr
	 *     NandExpr.NandExpr_1_0 returns XorExpr
	 *     AndExpr returns XorExpr
	 *     AndExpr.AndExpr_1_0 returns XorExpr
	 *     PrimaryExpr returns XorExpr
	 *
	 * Constraint:
	 *     (left=XorExpr_XorExpr_1_0 right=MinusExpr)
	 */
	protected void sequence_XorExpr(ISerializationContext context, XorExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SuperModCorePackage.Literals.BINARY_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXorExprAccess().getXorExprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getXorExprAccess().getRightMinusExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
}
