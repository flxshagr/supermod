/*
 * generated by Xtext
 */
package de.ubt.ai1.supermod.oel.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class OptionLangGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class OptionExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.OptionExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBiconditionalExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBigExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//OptionExpr core::OptionExpr:
		//	BiconditionalExpr | BigExpr;
		@Override public ParserRule getRule() { return rule; }

		//BiconditionalExpr | BigExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//BiconditionalExpr
		public RuleCall getBiconditionalExprParserRuleCall_0() { return cBiconditionalExprParserRuleCall_0; }

		//BigExpr
		public RuleCall getBigExprParserRuleCall_1() { return cBigExprParserRuleCall_1; }
	}

	public class BiconditionalExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.BiconditionalExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cImpliesExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBiconditionalExprLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cK_IFFTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBiconditionalExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//BiconditionalExpr core::OptionExpr:
		//	ImpliesExpr ({core::BiconditionalExpr.left=current} K_IFF right=BiconditionalExpr)*;
		@Override public ParserRule getRule() { return rule; }

		//ImpliesExpr ({core::BiconditionalExpr.left=current} K_IFF right=BiconditionalExpr)*
		public Group getGroup() { return cGroup; }

		//ImpliesExpr
		public RuleCall getImpliesExprParserRuleCall_0() { return cImpliesExprParserRuleCall_0; }

		//({core::BiconditionalExpr.left=current} K_IFF right=BiconditionalExpr)*
		public Group getGroup_1() { return cGroup_1; }

		//{core::BiconditionalExpr.left=current}
		public Action getBiconditionalExprLeftAction_1_0() { return cBiconditionalExprLeftAction_1_0; }

		//K_IFF
		public RuleCall getK_IFFTerminalRuleCall_1_1() { return cK_IFFTerminalRuleCall_1_1; }

		//right=BiconditionalExpr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//BiconditionalExpr
		public RuleCall getRightBiconditionalExprParserRuleCall_1_2_0() { return cRightBiconditionalExprParserRuleCall_1_2_0; }
	}

	public class ImpliesExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.ImpliesExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cImpliesExprLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cK_IMPTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOrExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ImpliesExpr core::OptionExpr:
		//	OrExpr ({core::ImpliesExpr.left=current} K_IMP right=OrExpr)*;
		@Override public ParserRule getRule() { return rule; }

		//OrExpr ({core::ImpliesExpr.left=current} K_IMP right=OrExpr)*
		public Group getGroup() { return cGroup; }

		//OrExpr
		public RuleCall getOrExprParserRuleCall_0() { return cOrExprParserRuleCall_0; }

		//({core::ImpliesExpr.left=current} K_IMP right=OrExpr)*
		public Group getGroup_1() { return cGroup_1; }

		//{core::ImpliesExpr.left=current}
		public Action getImpliesExprLeftAction_1_0() { return cImpliesExprLeftAction_1_0; }

		//K_IMP
		public RuleCall getK_IMPTerminalRuleCall_1_1() { return cK_IMPTerminalRuleCall_1_1; }

		//right=OrExpr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//OrExpr
		public RuleCall getRightOrExprParserRuleCall_1_2_0() { return cRightOrExprParserRuleCall_1_2_0; }
	}

	public class OrExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.OrExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXorExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrExprLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cK_ORTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightXorExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//OrExpr core::OptionExpr:
		//	XorExpr ({core::OrExpr.left=current} K_OR right=XorExpr)*;
		@Override public ParserRule getRule() { return rule; }

		//XorExpr ({core::OrExpr.left=current} K_OR right=XorExpr)*
		public Group getGroup() { return cGroup; }

		//XorExpr
		public RuleCall getXorExprParserRuleCall_0() { return cXorExprParserRuleCall_0; }

		//({core::OrExpr.left=current} K_OR right=XorExpr)*
		public Group getGroup_1() { return cGroup_1; }

		//{core::OrExpr.left=current}
		public Action getOrExprLeftAction_1_0() { return cOrExprLeftAction_1_0; }

		//K_OR
		public RuleCall getK_ORTerminalRuleCall_1_1() { return cK_ORTerminalRuleCall_1_1; }

		//right=XorExpr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//XorExpr
		public RuleCall getRightXorExprParserRuleCall_1_2_0() { return cRightXorExprParserRuleCall_1_2_0; }
	}

	public class XorExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.XorExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMinusExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cXorExprLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cK_XORTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMinusExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//XorExpr core::OptionExpr:
		//	MinusExpr ({core::XorExpr.left=current} K_XOR right=MinusExpr)*;
		@Override public ParserRule getRule() { return rule; }

		//MinusExpr ({core::XorExpr.left=current} K_XOR right=MinusExpr)*
		public Group getGroup() { return cGroup; }

		//MinusExpr
		public RuleCall getMinusExprParserRuleCall_0() { return cMinusExprParserRuleCall_0; }

		//({core::XorExpr.left=current} K_XOR right=MinusExpr)*
		public Group getGroup_1() { return cGroup_1; }

		//{core::XorExpr.left=current}
		public Action getXorExprLeftAction_1_0() { return cXorExprLeftAction_1_0; }

		//K_XOR
		public RuleCall getK_XORTerminalRuleCall_1_1() { return cK_XORTerminalRuleCall_1_1; }

		//right=MinusExpr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//MinusExpr
		public RuleCall getRightMinusExprParserRuleCall_1_2_0() { return cRightMinusExprParserRuleCall_1_2_0; }
	}

	public class MinusExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.MinusExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNandExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMinusExprLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cK_MINUSTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightNandExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//MinusExpr core::OptionExpr:
		//	NandExpr ({core::MinusExpr.left=current} K_MINUS right=NandExpr)*;
		@Override public ParserRule getRule() { return rule; }

		//NandExpr ({core::MinusExpr.left=current} K_MINUS right=NandExpr)*
		public Group getGroup() { return cGroup; }

		//NandExpr
		public RuleCall getNandExprParserRuleCall_0() { return cNandExprParserRuleCall_0; }

		//({core::MinusExpr.left=current} K_MINUS right=NandExpr)*
		public Group getGroup_1() { return cGroup_1; }

		//{core::MinusExpr.left=current}
		public Action getMinusExprLeftAction_1_0() { return cMinusExprLeftAction_1_0; }

		//K_MINUS
		public RuleCall getK_MINUSTerminalRuleCall_1_1() { return cK_MINUSTerminalRuleCall_1_1; }

		//right=NandExpr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//NandExpr
		public RuleCall getRightNandExprParserRuleCall_1_2_0() { return cRightNandExprParserRuleCall_1_2_0; }
	}

	public class NandExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.NandExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cNandExprLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cK_NANDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//NandExpr core::OptionExpr:
		//	AndExpr ({core::NandExpr.left=current} K_NAND right=AndExpr)*;
		@Override public ParserRule getRule() { return rule; }

		//AndExpr ({core::NandExpr.left=current} K_NAND right=AndExpr)*
		public Group getGroup() { return cGroup; }

		//AndExpr
		public RuleCall getAndExprParserRuleCall_0() { return cAndExprParserRuleCall_0; }

		//({core::NandExpr.left=current} K_NAND right=AndExpr)*
		public Group getGroup_1() { return cGroup_1; }

		//{core::NandExpr.left=current}
		public Action getNandExprLeftAction_1_0() { return cNandExprLeftAction_1_0; }

		//K_NAND
		public RuleCall getK_NANDTerminalRuleCall_1_1() { return cK_NANDTerminalRuleCall_1_1; }

		//right=AndExpr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//AndExpr
		public RuleCall getRightAndExprParserRuleCall_1_2_0() { return cRightAndExprParserRuleCall_1_2_0; }
	}

	public class AndExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.AndExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndExprLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cK_ANDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AndExpr core::OptionExpr:
		//	PrimaryExpr ({core::AndExpr.left=current} K_AND right=PrimaryExpr)*;
		@Override public ParserRule getRule() { return rule; }

		//PrimaryExpr ({core::AndExpr.left=current} K_AND right=PrimaryExpr)*
		public Group getGroup() { return cGroup; }

		//PrimaryExpr
		public RuleCall getPrimaryExprParserRuleCall_0() { return cPrimaryExprParserRuleCall_0; }

		//({core::AndExpr.left=current} K_AND right=PrimaryExpr)*
		public Group getGroup_1() { return cGroup_1; }

		//{core::AndExpr.left=current}
		public Action getAndExprLeftAction_1_0() { return cAndExprLeftAction_1_0; }

		//K_AND
		public RuleCall getK_ANDTerminalRuleCall_1_1() { return cK_ANDTerminalRuleCall_1_1; }

		//right=PrimaryExpr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//PrimaryExpr
		public RuleCall getRightPrimaryExprParserRuleCall_1_2_0() { return cRightPrimaryExprParserRuleCall_1_2_0; }
	}

	public class PrimaryExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.PrimaryExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cP_OPENTerminalRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cImpliesExprParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cP_CLOSETerminalRuleCall_0_2 = (RuleCall)cGroup_0.eContents().get(2);
		private final RuleCall cOptionRefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cNegExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//PrimaryExpr core::OptionExpr:
		//	P_OPEN ImpliesExpr P_CLOSE | OptionRef | NegExpr;
		@Override public ParserRule getRule() { return rule; }

		//P_OPEN ImpliesExpr P_CLOSE | OptionRef | NegExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//P_OPEN ImpliesExpr P_CLOSE
		public Group getGroup_0() { return cGroup_0; }

		//P_OPEN
		public RuleCall getP_OPENTerminalRuleCall_0_0() { return cP_OPENTerminalRuleCall_0_0; }

		//ImpliesExpr
		public RuleCall getImpliesExprParserRuleCall_0_1() { return cImpliesExprParserRuleCall_0_1; }

		//P_CLOSE
		public RuleCall getP_CLOSETerminalRuleCall_0_2() { return cP_CLOSETerminalRuleCall_0_2; }

		//OptionRef
		public RuleCall getOptionRefParserRuleCall_1() { return cOptionRefParserRuleCall_1; }

		//NegExpr
		public RuleCall getNegExprParserRuleCall_2() { return cNegExprParserRuleCall_2; }
	}

	public class BigExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.BigExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBigAndExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBigOrExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBigXorExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cBigNandExprParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//BigExpr core::BigExpr:
		//	BigAndExpr | BigOrExpr | BigXorExpr | BigNandExpr;
		@Override public ParserRule getRule() { return rule; }

		//BigAndExpr | BigOrExpr | BigXorExpr | BigNandExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//BigAndExpr
		public RuleCall getBigAndExprParserRuleCall_0() { return cBigAndExprParserRuleCall_0; }

		//BigOrExpr
		public RuleCall getBigOrExprParserRuleCall_1() { return cBigOrExprParserRuleCall_1; }

		//BigXorExpr
		public RuleCall getBigXorExprParserRuleCall_2() { return cBigXorExprParserRuleCall_2; }

		//BigNandExpr
		public RuleCall getBigNandExprParserRuleCall_3() { return cBigNandExprParserRuleCall_3; }
	}

	public class BigAndExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.BigAndExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cK_BIG_ANDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cP_OPENTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cChildrenAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cChildrenOptionExprParserRuleCall_2_0 = (RuleCall)cChildrenAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cCOMMATerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cChildrenAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cChildrenOptionExprParserRuleCall_3_1_0 = (RuleCall)cChildrenAssignment_3_1.eContents().get(0);
		private final RuleCall cP_CLOSETerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//BigAndExpr core::BigAndExpr:
		//	K_BIG_AND P_OPEN children+=OptionExpr (COMMA children+=OptionExpr)* P_CLOSE;
		@Override public ParserRule getRule() { return rule; }

		//K_BIG_AND P_OPEN children+=OptionExpr (COMMA children+=OptionExpr)* P_CLOSE
		public Group getGroup() { return cGroup; }

		//K_BIG_AND
		public RuleCall getK_BIG_ANDTerminalRuleCall_0() { return cK_BIG_ANDTerminalRuleCall_0; }

		//P_OPEN
		public RuleCall getP_OPENTerminalRuleCall_1() { return cP_OPENTerminalRuleCall_1; }

		//children+=OptionExpr
		public Assignment getChildrenAssignment_2() { return cChildrenAssignment_2; }

		//OptionExpr
		public RuleCall getChildrenOptionExprParserRuleCall_2_0() { return cChildrenOptionExprParserRuleCall_2_0; }

		//(COMMA children+=OptionExpr)*
		public Group getGroup_3() { return cGroup_3; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_3_0() { return cCOMMATerminalRuleCall_3_0; }

		//children+=OptionExpr
		public Assignment getChildrenAssignment_3_1() { return cChildrenAssignment_3_1; }

		//OptionExpr
		public RuleCall getChildrenOptionExprParserRuleCall_3_1_0() { return cChildrenOptionExprParserRuleCall_3_1_0; }

		//P_CLOSE
		public RuleCall getP_CLOSETerminalRuleCall_4() { return cP_CLOSETerminalRuleCall_4; }
	}

	public class BigOrExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.BigOrExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cK_BIG_ORTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cP_OPENTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cChildrenAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cChildrenOptionExprParserRuleCall_2_0 = (RuleCall)cChildrenAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cCOMMATerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cChildrenAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cChildrenOptionExprParserRuleCall_3_1_0 = (RuleCall)cChildrenAssignment_3_1.eContents().get(0);
		private final RuleCall cP_CLOSETerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//BigOrExpr core::BigOrExpr:
		//	K_BIG_OR P_OPEN children+=OptionExpr (COMMA children+=OptionExpr)* P_CLOSE;
		@Override public ParserRule getRule() { return rule; }

		//K_BIG_OR P_OPEN children+=OptionExpr (COMMA children+=OptionExpr)* P_CLOSE
		public Group getGroup() { return cGroup; }

		//K_BIG_OR
		public RuleCall getK_BIG_ORTerminalRuleCall_0() { return cK_BIG_ORTerminalRuleCall_0; }

		//P_OPEN
		public RuleCall getP_OPENTerminalRuleCall_1() { return cP_OPENTerminalRuleCall_1; }

		//children+=OptionExpr
		public Assignment getChildrenAssignment_2() { return cChildrenAssignment_2; }

		//OptionExpr
		public RuleCall getChildrenOptionExprParserRuleCall_2_0() { return cChildrenOptionExprParserRuleCall_2_0; }

		//(COMMA children+=OptionExpr)*
		public Group getGroup_3() { return cGroup_3; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_3_0() { return cCOMMATerminalRuleCall_3_0; }

		//children+=OptionExpr
		public Assignment getChildrenAssignment_3_1() { return cChildrenAssignment_3_1; }

		//OptionExpr
		public RuleCall getChildrenOptionExprParserRuleCall_3_1_0() { return cChildrenOptionExprParserRuleCall_3_1_0; }

		//P_CLOSE
		public RuleCall getP_CLOSETerminalRuleCall_4() { return cP_CLOSETerminalRuleCall_4; }
	}

	public class BigXorExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.BigXorExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cK_BIG_XORTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cP_OPENTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cChildrenAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cChildrenOptionExprParserRuleCall_2_0 = (RuleCall)cChildrenAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cCOMMATerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cChildrenAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cChildrenOptionExprParserRuleCall_3_1_0 = (RuleCall)cChildrenAssignment_3_1.eContents().get(0);
		private final RuleCall cP_CLOSETerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//BigXorExpr core::BigXorExpr:
		//	K_BIG_XOR P_OPEN children+=OptionExpr (COMMA children+=OptionExpr)* P_CLOSE;
		@Override public ParserRule getRule() { return rule; }

		//K_BIG_XOR P_OPEN children+=OptionExpr (COMMA children+=OptionExpr)* P_CLOSE
		public Group getGroup() { return cGroup; }

		//K_BIG_XOR
		public RuleCall getK_BIG_XORTerminalRuleCall_0() { return cK_BIG_XORTerminalRuleCall_0; }

		//P_OPEN
		public RuleCall getP_OPENTerminalRuleCall_1() { return cP_OPENTerminalRuleCall_1; }

		//children+=OptionExpr
		public Assignment getChildrenAssignment_2() { return cChildrenAssignment_2; }

		//OptionExpr
		public RuleCall getChildrenOptionExprParserRuleCall_2_0() { return cChildrenOptionExprParserRuleCall_2_0; }

		//(COMMA children+=OptionExpr)*
		public Group getGroup_3() { return cGroup_3; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_3_0() { return cCOMMATerminalRuleCall_3_0; }

		//children+=OptionExpr
		public Assignment getChildrenAssignment_3_1() { return cChildrenAssignment_3_1; }

		//OptionExpr
		public RuleCall getChildrenOptionExprParserRuleCall_3_1_0() { return cChildrenOptionExprParserRuleCall_3_1_0; }

		//P_CLOSE
		public RuleCall getP_CLOSETerminalRuleCall_4() { return cP_CLOSETerminalRuleCall_4; }
	}

	public class BigNandExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.BigNandExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cK_BIG_NANDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cP_OPENTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cChildrenAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cChildrenOptionExprParserRuleCall_2_0 = (RuleCall)cChildrenAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cCOMMATerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cChildrenAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cChildrenOptionExprParserRuleCall_3_1_0 = (RuleCall)cChildrenAssignment_3_1.eContents().get(0);
		private final RuleCall cP_CLOSETerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//BigNandExpr core::BigNandExpr:
		//	K_BIG_NAND P_OPEN children+=OptionExpr (COMMA children+=OptionExpr)* P_CLOSE;
		@Override public ParserRule getRule() { return rule; }

		//K_BIG_NAND P_OPEN children+=OptionExpr (COMMA children+=OptionExpr)* P_CLOSE
		public Group getGroup() { return cGroup; }

		//K_BIG_NAND
		public RuleCall getK_BIG_NANDTerminalRuleCall_0() { return cK_BIG_NANDTerminalRuleCall_0; }

		//P_OPEN
		public RuleCall getP_OPENTerminalRuleCall_1() { return cP_OPENTerminalRuleCall_1; }

		//children+=OptionExpr
		public Assignment getChildrenAssignment_2() { return cChildrenAssignment_2; }

		//OptionExpr
		public RuleCall getChildrenOptionExprParserRuleCall_2_0() { return cChildrenOptionExprParserRuleCall_2_0; }

		//(COMMA children+=OptionExpr)*
		public Group getGroup_3() { return cGroup_3; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_3_0() { return cCOMMATerminalRuleCall_3_0; }

		//children+=OptionExpr
		public Assignment getChildrenAssignment_3_1() { return cChildrenAssignment_3_1; }

		//OptionExpr
		public RuleCall getChildrenOptionExprParserRuleCall_3_1_0() { return cChildrenOptionExprParserRuleCall_3_1_0; }

		//P_CLOSE
		public RuleCall getP_CLOSETerminalRuleCall_4() { return cP_CLOSETerminalRuleCall_4; }
	}

	public class OptionRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.OptionRef");
		private final Assignment cOptionAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cOptionOptionCrossReference_0 = (CrossReference)cOptionAssignment.eContents().get(0);
		private final RuleCall cOptionOptionIDTerminalRuleCall_0_1 = (RuleCall)cOptionOptionCrossReference_0.eContents().get(1);
		
		//OptionRef core::OptionRef:
		//	option=[core::Option];
		@Override public ParserRule getRule() { return rule; }

		//option=[core::Option]
		public Assignment getOptionAssignment() { return cOptionAssignment; }

		//[core::Option]
		public CrossReference getOptionOptionCrossReference_0() { return cOptionOptionCrossReference_0; }

		//ID
		public RuleCall getOptionOptionIDTerminalRuleCall_0_1() { return cOptionOptionIDTerminalRuleCall_0_1; }
	}

	public class NegExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.NegExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cK_NOTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cNegAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNegOptionExprParserRuleCall_1_0 = (RuleCall)cNegAssignment_1.eContents().get(0);
		
		//NegExpr core::NegExpr:
		//	K_NOT neg=OptionExpr;
		@Override public ParserRule getRule() { return rule; }

		//K_NOT neg=OptionExpr
		public Group getGroup() { return cGroup; }

		//K_NOT
		public RuleCall getK_NOTTerminalRuleCall_0() { return cK_NOTTerminalRuleCall_0; }

		//neg=OptionExpr
		public Assignment getNegAssignment_1() { return cNegAssignment_1; }

		//OptionExpr
		public RuleCall getNegOptionExprParserRuleCall_1_0() { return cNegOptionExprParserRuleCall_1_0; }
	}
	
	
	private final OptionExprElements pOptionExpr;
	private final BiconditionalExprElements pBiconditionalExpr;
	private final ImpliesExprElements pImpliesExpr;
	private final OrExprElements pOrExpr;
	private final XorExprElements pXorExpr;
	private final MinusExprElements pMinusExpr;
	private final NandExprElements pNandExpr;
	private final AndExprElements pAndExpr;
	private final PrimaryExprElements pPrimaryExpr;
	private final BigExprElements pBigExpr;
	private final BigAndExprElements pBigAndExpr;
	private final BigOrExprElements pBigOrExpr;
	private final BigXorExprElements pBigXorExpr;
	private final BigNandExprElements pBigNandExpr;
	private final OptionRefElements pOptionRef;
	private final NegExprElements pNegExpr;
	private final TerminalRule tP_OPEN;
	private final TerminalRule tP_CLOSE;
	private final TerminalRule tK_NOT;
	private final TerminalRule tK_AND;
	private final TerminalRule tK_OR;
	private final TerminalRule tK_XOR;
	private final TerminalRule tK_IMP;
	private final TerminalRule tK_IFF;
	private final TerminalRule tK_MINUS;
	private final TerminalRule tK_NAND;
	private final TerminalRule tK_BIG_AND;
	private final TerminalRule tK_BIG_OR;
	private final TerminalRule tK_BIG_XOR;
	private final TerminalRule tK_BIG_NAND;
	private final TerminalRule tCOMMA;
	private final TerminalRule tID;
	private final TerminalRule tWS;
	
	private final Grammar grammar;

	@Inject
	public OptionLangGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pOptionExpr = new OptionExprElements();
		this.pBiconditionalExpr = new BiconditionalExprElements();
		this.pImpliesExpr = new ImpliesExprElements();
		this.pOrExpr = new OrExprElements();
		this.pXorExpr = new XorExprElements();
		this.pMinusExpr = new MinusExprElements();
		this.pNandExpr = new NandExprElements();
		this.pAndExpr = new AndExprElements();
		this.pPrimaryExpr = new PrimaryExprElements();
		this.pBigExpr = new BigExprElements();
		this.pBigAndExpr = new BigAndExprElements();
		this.pBigOrExpr = new BigOrExprElements();
		this.pBigXorExpr = new BigXorExprElements();
		this.pBigNandExpr = new BigNandExprElements();
		this.pOptionRef = new OptionRefElements();
		this.pNegExpr = new NegExprElements();
		this.tP_OPEN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.P_OPEN");
		this.tP_CLOSE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.P_CLOSE");
		this.tK_NOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.K_NOT");
		this.tK_AND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.K_AND");
		this.tK_OR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.K_OR");
		this.tK_XOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.K_XOR");
		this.tK_IMP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.K_IMP");
		this.tK_IFF = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.K_IFF");
		this.tK_MINUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.K_MINUS");
		this.tK_NAND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.K_NAND");
		this.tK_BIG_AND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.K_BIG_AND");
		this.tK_BIG_OR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.K_BIG_OR");
		this.tK_BIG_XOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.K_BIG_XOR");
		this.tK_BIG_NAND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.K_BIG_NAND");
		this.tCOMMA = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.COMMA");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.ID");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.ubt.ai1.supermod.oel.OptionLang.WS");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("de.ubt.ai1.supermod.oel.OptionLang".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//OptionExpr core::OptionExpr:
	//	BiconditionalExpr | BigExpr;
	public OptionExprElements getOptionExprAccess() {
		return pOptionExpr;
	}
	
	public ParserRule getOptionExprRule() {
		return getOptionExprAccess().getRule();
	}

	//BiconditionalExpr core::OptionExpr:
	//	ImpliesExpr ({core::BiconditionalExpr.left=current} K_IFF right=BiconditionalExpr)*;
	public BiconditionalExprElements getBiconditionalExprAccess() {
		return pBiconditionalExpr;
	}
	
	public ParserRule getBiconditionalExprRule() {
		return getBiconditionalExprAccess().getRule();
	}

	//ImpliesExpr core::OptionExpr:
	//	OrExpr ({core::ImpliesExpr.left=current} K_IMP right=OrExpr)*;
	public ImpliesExprElements getImpliesExprAccess() {
		return pImpliesExpr;
	}
	
	public ParserRule getImpliesExprRule() {
		return getImpliesExprAccess().getRule();
	}

	//OrExpr core::OptionExpr:
	//	XorExpr ({core::OrExpr.left=current} K_OR right=XorExpr)*;
	public OrExprElements getOrExprAccess() {
		return pOrExpr;
	}
	
	public ParserRule getOrExprRule() {
		return getOrExprAccess().getRule();
	}

	//XorExpr core::OptionExpr:
	//	MinusExpr ({core::XorExpr.left=current} K_XOR right=MinusExpr)*;
	public XorExprElements getXorExprAccess() {
		return pXorExpr;
	}
	
	public ParserRule getXorExprRule() {
		return getXorExprAccess().getRule();
	}

	//MinusExpr core::OptionExpr:
	//	NandExpr ({core::MinusExpr.left=current} K_MINUS right=NandExpr)*;
	public MinusExprElements getMinusExprAccess() {
		return pMinusExpr;
	}
	
	public ParserRule getMinusExprRule() {
		return getMinusExprAccess().getRule();
	}

	//NandExpr core::OptionExpr:
	//	AndExpr ({core::NandExpr.left=current} K_NAND right=AndExpr)*;
	public NandExprElements getNandExprAccess() {
		return pNandExpr;
	}
	
	public ParserRule getNandExprRule() {
		return getNandExprAccess().getRule();
	}

	//AndExpr core::OptionExpr:
	//	PrimaryExpr ({core::AndExpr.left=current} K_AND right=PrimaryExpr)*;
	public AndExprElements getAndExprAccess() {
		return pAndExpr;
	}
	
	public ParserRule getAndExprRule() {
		return getAndExprAccess().getRule();
	}

	//PrimaryExpr core::OptionExpr:
	//	P_OPEN ImpliesExpr P_CLOSE | OptionRef | NegExpr;
	public PrimaryExprElements getPrimaryExprAccess() {
		return pPrimaryExpr;
	}
	
	public ParserRule getPrimaryExprRule() {
		return getPrimaryExprAccess().getRule();
	}

	//BigExpr core::BigExpr:
	//	BigAndExpr | BigOrExpr | BigXorExpr | BigNandExpr;
	public BigExprElements getBigExprAccess() {
		return pBigExpr;
	}
	
	public ParserRule getBigExprRule() {
		return getBigExprAccess().getRule();
	}

	//BigAndExpr core::BigAndExpr:
	//	K_BIG_AND P_OPEN children+=OptionExpr (COMMA children+=OptionExpr)* P_CLOSE;
	public BigAndExprElements getBigAndExprAccess() {
		return pBigAndExpr;
	}
	
	public ParserRule getBigAndExprRule() {
		return getBigAndExprAccess().getRule();
	}

	//BigOrExpr core::BigOrExpr:
	//	K_BIG_OR P_OPEN children+=OptionExpr (COMMA children+=OptionExpr)* P_CLOSE;
	public BigOrExprElements getBigOrExprAccess() {
		return pBigOrExpr;
	}
	
	public ParserRule getBigOrExprRule() {
		return getBigOrExprAccess().getRule();
	}

	//BigXorExpr core::BigXorExpr:
	//	K_BIG_XOR P_OPEN children+=OptionExpr (COMMA children+=OptionExpr)* P_CLOSE;
	public BigXorExprElements getBigXorExprAccess() {
		return pBigXorExpr;
	}
	
	public ParserRule getBigXorExprRule() {
		return getBigXorExprAccess().getRule();
	}

	//BigNandExpr core::BigNandExpr:
	//	K_BIG_NAND P_OPEN children+=OptionExpr (COMMA children+=OptionExpr)* P_CLOSE;
	public BigNandExprElements getBigNandExprAccess() {
		return pBigNandExpr;
	}
	
	public ParserRule getBigNandExprRule() {
		return getBigNandExprAccess().getRule();
	}

	//OptionRef core::OptionRef:
	//	option=[core::Option];
	public OptionRefElements getOptionRefAccess() {
		return pOptionRef;
	}
	
	public ParserRule getOptionRefRule() {
		return getOptionRefAccess().getRule();
	}

	//NegExpr core::NegExpr:
	//	K_NOT neg=OptionExpr;
	public NegExprElements getNegExprAccess() {
		return pNegExpr;
	}
	
	public ParserRule getNegExprRule() {
		return getNegExprAccess().getRule();
	}

	//terminal P_OPEN:
	//	'(';
	public TerminalRule getP_OPENRule() {
		return tP_OPEN;
	} 

	//terminal P_CLOSE:
	//	')';
	public TerminalRule getP_CLOSERule() {
		return tP_CLOSE;
	} 

	//terminal K_NOT:
	//	'not';
	public TerminalRule getK_NOTRule() {
		return tK_NOT;
	} 

	//terminal K_AND:
	//	'and';
	public TerminalRule getK_ANDRule() {
		return tK_AND;
	} 

	//terminal K_OR:
	//	'or';
	public TerminalRule getK_ORRule() {
		return tK_OR;
	} 

	//terminal K_XOR:
	//	'xor';
	public TerminalRule getK_XORRule() {
		return tK_XOR;
	} 

	//terminal K_IMP:
	//	'implies';
	public TerminalRule getK_IMPRule() {
		return tK_IMP;
	} 

	//terminal K_IFF:
	//	'iff';
	public TerminalRule getK_IFFRule() {
		return tK_IFF;
	} 

	//terminal K_MINUS:
	//	'minus';
	public TerminalRule getK_MINUSRule() {
		return tK_MINUS;
	} 

	//terminal K_NAND:
	//	'nand';
	public TerminalRule getK_NANDRule() {
		return tK_NAND;
	} 

	//terminal K_BIG_AND:
	//	'AND';
	public TerminalRule getK_BIG_ANDRule() {
		return tK_BIG_AND;
	} 

	//terminal K_BIG_OR:
	//	'OR';
	public TerminalRule getK_BIG_ORRule() {
		return tK_BIG_OR;
	} 

	//terminal K_BIG_XOR:
	//	'XOR';
	public TerminalRule getK_BIG_XORRule() {
		return tK_BIG_XOR;
	} 

	//terminal K_BIG_NAND:
	//	'NAND';
	public TerminalRule getK_BIG_NANDRule() {
		return tK_BIG_NAND;
	} 

	//terminal COMMA:
	//	',';
	public TerminalRule getCOMMARule() {
		return tCOMMA;
	} 

	//terminal ID:
	//	('a'..'z' | 'A'..'Z' | '_' | '-') ('a'..'z' | 'A'..'Z' | '_' | '-' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return tID;
	} 

	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return tWS;
	} 
}
